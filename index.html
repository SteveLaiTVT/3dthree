<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>高精细粒子手势</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; }
        canvas { display: block; }
        #debug-panel {
            position: absolute; top: 10px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
        }
        #status-text {
            color: #00ff88; background: rgba(0,0,0,0.6);
            padding: 8px 16px; border-radius: 20px; font-family: sans-serif; font-size: 14px;
            display: inline-block; border: 1px solid rgba(0,255,136,0.3);
        }
        #webcam {
            position: absolute; bottom: 10px; right: 10px;
            width: 120px; transform: scaleX(-1); opacity: 0.8;
            border-radius: 8px; border: 2px solid #333; z-index: 50;
        }
    </style>
</head>
<body>

    <div id="debug-panel">
        <span id="status-text">系统初始化中...</span>
    </div>
    
    <video id="webcam" autoplay playsinline muted></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- 核心调整参数 ---
        const PARTICLE_COUNT = 25000; // 粒子数量
        
        // 1. 放大骨架比例：让手指骨头之间的物理距离变远
        const HAND_SCALE = 80.0;      
        
        // 2. 粒子紧凑度：数值越小，手指越细，缝隙越明显 (之前是 0.5-0.8)
        const FINGER_THICKNESS = 0.25; 

        const isMobile = window.innerWidth < 768;
        const statusText = document.getElementById('status-text');
        const video = document.getElementById('webcam');

        // --- Three.js ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015); // 增加一点深邃感

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // 因为 HAND_SCALE 变大了，相机也要拉远一点才能看到全貌
        camera.position.z = isMobile ? 120 : 90; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.rotateSpeed = 0.5;

        // --- 粒子系统 ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const particleMeta = [];

        // 骨骼定义
        const bones = [
            [0,1,1.2],[1,2,1.0],[2,3,0.9],[3,4,0.8], // 拇指
            [0,5,1.1],[5,6,0.9],[6,7,0.8],[7,8,0.7], // 食指 (变细)
            [0,9,1.1],[9,10,0.9],[10,11,0.8],[11,12,0.7], // 中指
            [0,13,1.0],[13,14,0.9],[14,15,0.8],[15,16,0.7], // 无名指
            [0,17,0.9],[17,18,0.8],[18,19,0.7],[19,20,0.6], // 小指
            // 手掌部分保持稍厚
            [5,9,1.5],[9,13,1.5],[13,17,1.5],[0,5,1.5],[0,17,1.5] 
        ];

        // 初始化
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // 初始星云形态
            const r = 20 * Math.random();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = r * Math.cos(phi);

            // 分配骨骼
            const boneIdx = Math.floor(Math.random() * bones.length);
            // power(..., 1.5) 让粒子更多集中在关节中心，边缘更少，视觉上更清晰
            const radiusProfile = Math.pow(Math.random(), 1.5); 
            
            particleMeta.push({
                boneIdx: boneIdx,
                t: Math.random(), // 0-1 线性位置
                radius: radiusProfile, // 径向分布
                angle: Math.random() * Math.PI * 2
            });
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            size: isMobile ? 1.0 : 0.6, // 粒子大小
            color: 0x00d2ff,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- MediaPipe ---
        let handLandmarker = undefined;
        let latestLandmarks = null;

        async function startApp() {
            try {
                statusText.innerText = "加载 AI 模型...";
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } }
                });
                video.srcObject = stream;
                video.onloadeddata = () => {
                    statusText.innerText = "请举手 - 保持距离";
                    predictLoop();
                };

            } catch (err) {
                statusText.innerText = "错误: 需要 HTTPS 或 摄像头权限";
                statusText.style.color = "red";
            }
        }

        let lastVideoTime = -1;
        function predictLoop() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    if (result.worldLandmarks && result.worldLandmarks.length > 0) {
                        latestLandmarks = result.worldLandmarks[0];
                        statusText.innerText = "● 实时追踪中";
                        statusText.style.color = "#00ff88";
                        statusText.style.borderColor = "#00ff88";
                    } else {
                        statusText.innerText = "○ 寻找手势...";
                        statusText.style.color = "#aaa";
                        statusText.style.borderColor = "#555";
                    }
                }
            }
            requestAnimationFrame(predictLoop);
        }

        startApp();

        // --- 动画循环 ---
        const vStart = new THREE.Vector3();
        const vEnd = new THREE.Vector3();
        const vPos = new THREE.Vector3();
        // 预计算坐标轴用于体积模拟
        const vDir = new THREE.Vector3();
        const vUp = new THREE.Vector3(0, 1, 0);
        const vU = new THREE.Vector3();
        const vV = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const posArr = geometry.attributes.position.array;

            if (latestLandmarks) {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const meta = particleMeta[i];
                    const boneData = bones[meta.boneIdx];
                    
                    const p1 = latestLandmarks[boneData[0]];
                    const p2 = latestLandmarks[boneData[1]];
                    
                    // 1. 骨架缩放 (拉大间距)
                    vStart.set(-p1.x, -p1.y, -p1.z).multiplyScalar(HAND_SCALE);
                    vEnd.set(-p2.x, -p2.y, -p2.z).multiplyScalar(HAND_SCALE);
                    
                    // 2. 计算方向和垂直轴 (为了让粒子垂直于骨头分布，而不是乱飞)
                    vDir.subVectors(vEnd, vStart).normalize();
                    // 构建局部坐标系
                    if (Math.abs(vDir.y) > 0.99) vU.crossVectors(vDir, new THREE.Vector3(1, 0, 0)).normalize();
                    else vU.crossVectors(vDir, vUp).normalize();
                    vV.crossVectors(vU, vDir).normalize();

                    // 3. 基础位置 (骨头上的一点)
                    vPos.lerpVectors(vStart, vEnd, meta.t);

                    // 4. 计算厚度 (瘦身关键点)
                    // FINGER_THICKNESS 控制整体粗细
                    // boneData[2] 是这根手指的权重(拇指粗小指细)
                    // meta.radius 是粒子的随机分布位置
                    const thickness = FINGER_THICKNESS * boneData[2] * meta.radius * HAND_SCALE * 0.15;
                    
                    const offsetX = thickness * Math.cos(meta.angle);
                    const offsetY = thickness * Math.sin(meta.angle);

                    // 5. 最终目标位置 = 骨头点 + 垂直方向的偏移
                    const targetX = vPos.x + vU.x * offsetX + vV.x * offsetX;
                    const targetY = vPos.y + vU.y * offsetY + vV.y * offsetY;
                    const targetZ = vPos.z + vU.z * offsetX + vV.z * offsetY;

                    // 6. 平滑移动
                    const idx = i * 3;
                    posArr[idx]   += (targetX - posArr[idx]) * 0.2; // 0.2 响应速度
                    posArr[idx+1] += (targetY - posArr[idx+1]) * 0.2;
                    posArr[idx+2] += (targetZ - posArr[idx+2]) * 0.2;
                }
            } else {
                particles.rotation.y += 0.003;
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>