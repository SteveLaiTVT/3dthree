<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>手机端粒子手势</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; /* 禁止浏览器默认触摸行为 */ }
        canvas { display: block; }

        /* 调试面板 - 放在手机屏幕上方不易遮挡处 */
        #debug-panel {
            position: absolute; top: 10px; left: 10px; right: 10px;
            color: #00ff88; background: rgba(0,0,0,0.6);
            padding: 10px; border-radius: 8px; font-size: 14px;
            pointer-events: none; z-index: 100; text-align: center;
        }

        /* 摄像头预览 - 放在右下角，缩小一点 */
        #webcam {
            position: absolute; bottom: 10px; right: 10px;
            width: 100px; transform: scaleX(-1); /* 镜像 */
            opacity: 0.6; border: 1px solid #444; border-radius: 4px; z-index: 50;
        }
    </style>
</head>
<body>

    <div id="debug-panel">
        <div id="status-text">系统初始化中...</div>
        <div style="font-size:10px; color:#ccc; margin-top:5px;">请确保使用 HTTPS 链接访问</div>
    </div>
    
    <video id="webcam" autoplay playsinline muted></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- 手机端配置 ---
        const PARTICLE_COUNT = 20000; // 降低粒子数，保证手机流畅
        const HAND_SCALE = 25.0;      
        const isMobile = window.innerWidth < 768;

        const statusText = document.getElementById('status-text');
        const video = document.getElementById('webcam');

        // --- 1. Three.js 场景 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // 手机竖屏时，相机要拉远一点，否则手显示不全
        camera.position.z = isMobile ? 45 : 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.rotateSpeed = 0.5; // 降低触摸灵敏度

        // --- 2. 粒子构建 (同前，简化版) ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const particleMeta = [];

        // 骨骼定义
        const bones = [
            [0,1,1],[1,2,1],[2,3,1],[3,4,1], // 拇指
            [0,5,1],[5,6,1],[6,7,1],[7,8,1], // 食指
            [0,9,1],[9,10,1],[10,11,1],[11,12,1], // 中指
            [0,13,1],[13,14,1],[14,15,1],[15,16,1], // 无名指
            [0,17,1],[17,18,1],[18,19,1],[19,20,1], // 小指
            [5,9,1.2],[9,13,1.2],[13,17,1.2],[0,5,1.2],[0,17,1.2] // 手掌
        ];

        // 初始化一团星云
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const r = 15 * Math.random();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = r * Math.cos(phi);

            particleMeta.push({
                boneIdx: Math.floor(Math.random() * bones.length),
                t: Math.random(),
                radius: Math.random() * 0.5,
                angle: Math.random() * Math.PI * 2
            });
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            size: isMobile ? 0.4 : 0.2, // 手机上粒子稍微大一点才看得清
            color: 0x00d2ff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. MediaPipe (手机适配) ---
        let handLandmarker = undefined;
        let latestLandmarks = null;

        async function startApp() {
            try {
                statusText.innerText = "下载 AI 模型 (约10MB)...";
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                statusText.innerText = "初始化相机...";
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                // 关键：手机摄像头请求参数
                const constraints = {
                    video: {
                        facingMode: "user", // 强制前置摄像头
                        width: { ideal: 640 }, // 降低分辨率提高速度
                        height: { ideal: 480 }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.onloadeddata = () => {
                    statusText.innerText = "请对着前置镜头举手";
                    statusText.style.color = "#ffff00";
                    predictLoop();
                };

            } catch (err) {
                console.error(err);
                statusText.innerHTML = "无法启动摄像头!<br>请确保是用 HTTPS 链接打开";
                statusText.style.color = "red";
            }
        }

        let lastVideoTime = -1;
        function predictLoop() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const startTime = performance.now();
                    const result = handLandmarker.detectForVideo(video, startTime);
                    if (result.worldLandmarks && result.worldLandmarks.length > 0) {
                        latestLandmarks = result.worldLandmarks[0];
                        statusText.innerText = "已捕捉手势";
                        statusText.style.color = "#00ff88";
                    } else {
                        // 手机上手容易出画，保留最后一帧数据，或者清空
                        // latestLandmarks = null; 
                        statusText.innerText = "寻找手势...";
                        statusText.style.color = "#ffaa00";
                    }
                }
            }
            requestAnimationFrame(predictLoop);
        }

        startApp();

        // --- 4. 动画循环 ---
        const vStart = new THREE.Vector3();
        const vEnd = new THREE.Vector3();
        const vPos = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const posArr = geometry.attributes.position.array;

            if (latestLandmarks) {
                // 手机上为了看清手，可以把手整体放大一点
                const scale = HAND_SCALE * (isMobile ? 1.2 : 1.0);

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const meta = particleMeta[i];
                    const bone = bones[meta.boneIdx];
                    
                    const p1 = latestLandmarks[bone[0]];
                    const p2 = latestLandmarks[bone[1]];
                    
                    // 镜像并缩放
                    vStart.set(-p1.x, -p1.y, -p1.z).multiplyScalar(scale);
                    vEnd.set(-p2.x, -p2.y, -p2.z).multiplyScalar(scale);
                    
                    // 简单的线性插值 + 随机抖动 (手机版为了性能去掉了复杂的叉乘计算)
                    vPos.lerpVectors(vStart, vEnd, meta.t);
                    
                    // 简化的体积模拟
                    const jitter = 0.5 + meta.radius * 2; 
                    
                    const idx = i * 3;
                    // 使用阻尼运动平滑过渡
                    posArr[idx]   += (vPos.x + (Math.random()-0.5)*jitter - posArr[idx]) * 0.15;
                    posArr[idx+1] += (vPos.y + (Math.random()-0.5)*jitter - posArr[idx+1]) * 0.15;
                    posArr[idx+2] += (vPos.z + (Math.random()-0.5)*jitter - posArr[idx+2]) * 0.15;
                }
            } else {
                // 待机动画：缓慢旋转
                particles.rotation.y += 0.002;
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // 屏幕旋转适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>