<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>高精细粒子手势 - 间隙优化版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; }
        canvas { display: block; }
        #debug-panel {
            position: absolute; top: 10px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
        }
        #status-text {
            color: #00ff88; background: rgba(0,0,0,0.6);
            padding: 8px 16px; border-radius: 20px; font-family: sans-serif; font-size: 14px;
            display: inline-block; border: 1px solid rgba(0,255,136,0.3);
        }
        #webcam {
            position: absolute; bottom: 10px; right: 10px;
            width: 120px; transform: scaleX(-1); opacity: 0.8;
            border-radius: 8px; border: 2px solid #333; z-index: 50;
        }
    </style>
</head>
<body>

    <div id="debug-panel">
        <span id="status-text">系统初始化中...</span>
    </div>
    
    <video id="webcam" autoplay playsinline muted></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- 核心调整参数 (针对间隙优化) ---
        // 1. 减少粒子数量，让每个粒子更清晰
        const PARTICLE_COUNT = 15000; 
        
        // 2. 极大增加骨架比例：拉开手指间的物理距离
        const HAND_SCALE = 150.0;      
        
        // 3. 极小化粒子扩散：让粒子紧贴骨骼，不再是圆柱体
        const FINGER_THICKNESS = 0.08; 

        const isMobile = window.innerWidth < 768;
        const statusText = document.getElementById('status-text');
        const video = document.getElementById('webcam');

        // --- Three.js ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.01);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // 骨架很大，相机要拉得非常远
        camera.position.z = isMobile ? 180 : 140; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.rotateSpeed = 0.5;

        // --- 粒子系统 ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const particleMeta = [];

        // 骨骼定义
        const bones = [
            [0,1,1.0],[1,2,1.0],[2,3,1.0],[3,4,1.0], // 拇指
            [0,5,1.0],[5,6,1.0],[6,7,1.0],[7,8,1.0], // 食指
            [0,9,1.0],[9,10,1.0],[10,11,1.0],[11,12,1.0], // 中指
            [0,13,1.0],[13,14,1.0],[14,15,1.0],[15,16,1.0], // 无名指
            [0,17,1.0],[17,18,1.0],[18,19,1.0],[19,20,1.0], // 小指
            [5,9,1.0],[9,13,1.0],[13,17,1.0],[0,5,1.0],[0,17,1.0] 
        ];

        // 初始化
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const r = 20 * Math.random();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = r * Math.cos(phi);

            // 4. 关键修改：让粒子极其集中在中心线上
            // 使用更高的 power 值 (2.5)，使得绝大多数粒子半径接近于 0
            const radiusProfile = Math.pow(Math.random(), 2.5); 
            
            particleMeta.push({
                boneIdx: Math.floor(Math.random() * bones.length),
                t: Math.random(),
                radius: radiusProfile, 
                angle: Math.random() * Math.PI * 2
            });
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            // 5. 增大粒子尺寸，减少数量但增加单个粒子的存在感
            size: isMobile ? 1.8 : 1.0, 
            color: 0x00d2ff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- MediaPipe ---
        let handLandmarker = undefined;
        let latestLandmarks = null;

        async function startApp() {
            try {
                statusText.innerText = "加载 AI 模型...";
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } }
                });
                video.srcObject = stream;
                video.onloadeddata = () => {
                    statusText.innerText = "请举手 - 保持距离";
                    predictLoop();
                };

            } catch (err) {
                statusText.innerText = "错误: 需要 HTTPS 或 摄像头权限";
                statusText.style.color = "red";
            }
        }

        let lastVideoTime = -1;
        function predictLoop() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    if (result.worldLandmarks && result.worldLandmarks.length > 0) {
                        latestLandmarks = result.worldLandmarks[0];
                        statusText.innerText = "● 实时追踪中";
                        statusText.style.color = "#00ff88";
                        statusText.style.borderColor = "#00ff88";
                    } else {
                        statusText.innerText = "○ 寻找手势...";
                        statusText.style.color = "#aaa";
                        statusText.style.borderColor = "#555";
                    }
                }
            }
            requestAnimationFrame(predictLoop);
        }

        startApp();

        // --- 动画循环 ---
        const vStart = new THREE.Vector3();
        const vEnd = new THREE.Vector3();
        const vPos = new THREE.Vector3();
        const vDir = new THREE.Vector3();
        const vUp = new THREE.Vector3(0, 1, 0);
        const vU = new THREE.Vector3();
        const vV = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const posArr = geometry.attributes.position.array;

            if (latestLandmarks) {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const meta = particleMeta[i];
                    const boneData = bones[meta.boneIdx];
                    
                    const p1 = latestLandmarks[boneData[0]];
                    const p2 = latestLandmarks[boneData[1]];
                    
                    vStart.set(-p1.x, -p1.y, -p1.z).multiplyScalar(HAND_SCALE);
                    vEnd.set(-p2.x, -p2.y, -p2.z).multiplyScalar(HAND_SCALE);
                    
                    vDir.subVectors(vEnd, vStart).normalize();
                    if (Math.abs(vDir.y) > 0.99) vU.crossVectors(vDir, new THREE.Vector3(1, 0, 0)).normalize();
                    else vU.crossVectors(vDir, vUp).normalize();
                    vV.crossVectors(vU, vDir).normalize();

                    vPos.lerpVectors(vStart, vEnd, meta.t);

                    // 计算极小的厚度
                    const thickness = FINGER_THICKNESS * boneData[2] * meta.radius * HAND_SCALE * 0.15;
                    
                    const offsetX = thickness * Math.cos(meta.angle);
                    const offsetY = thickness * Math.sin(meta.angle);

                    const targetX = vPos.x + vU.x * offsetX + vV.x * offsetX;
                    const targetY = vPos.y + vU.y * offsetY + vV.y * offsetY;
                    const targetZ = vPos.z + vU.z * offsetX + vV.z * offsetY;

                    const idx = i * 3;
                    posArr[idx]   += (targetX - posArr[idx]) * 0.25; // 稍微加快响应速度
                    posArr[idx+1] += (targetY - posArr[idx+1]) * 0.25;
                    posArr[idx+2] += (targetZ - posArr[idx+2]) * 0.25;
                }
            } else {
                particles.rotation.y += 0.003;
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>